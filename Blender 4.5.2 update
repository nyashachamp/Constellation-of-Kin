# Constellation of Kin — Blender Script with Embedded JSON (Blender 3.x & 4.x safe)

import bpy, json, math, mathutils, os
# ---- Glow boost for Eevee Next ----
for mat in bpy.data.materials:
    if mat.use_nodes:
        for n in mat.node_tree.nodes:
            if n.type == "EMISSION":
                n.inputs["Strength"].default_value = 50.0  # bump brightness


# ========= TIMING / VISUAL SETTINGS =========
FPS = 30
SCENE_DURATION_SECONDS = 14      # adjust if you add more timeline events
STAR_SIZE = 0.11                 # base size of stars
GLOW_STRENGTH = 20.0             # base designer intent (we'll override per engine)
EDGE_WIDTH = 0.01
LAYOUT_RADIUS = 5.0              # used if no fixed pos provided

# ========= YOUR EMBEDDED JSON (Dixon/Kennedy line) =========
json_text = r"""
{
  "people": [
    { "id":"p1","name":"Hugh Johnson Kennedy","glow":"blue-green","side":"paternal" },
    { "id":"p2","name":"Mildred Wagstaff Hutchinson","glow":"white-gold","side":"maternal" },
    { "id":"p3","name":"Johnson John Kennedy","glow":"emerald","side":"paternal" },
    { "id":"p4","name":"Mom Dixon","glow":"earth","side":"maternal" },
    { "id":"p5","name":"Gilbert Dixon","glow":"gold","side":"paternal" },
    { "id":"p6","name":"Venus Penny Dixon","glow":"bronze","side":"maternal" },
    { "id":"p7","name":"James Dixon","glow":"crimson","side":"paternal" },
    { "id":"p8","name":"Lavinia Dinkins","glow":"green","side":"maternal" },
    { "id":"p9","name":"Eugene Dixon","glow":"bronze-gold","side":"paternal" },
    { "id":"p10","name":"Marie Dixon","glow":"pale_blue","side":"maternal" },
    { "id":"p11","name":"Carl Dixon, Sr.","glow":"white-gold","side":"paternal" },
    { "id":"p12","name":"Cecelia Webb","glow":"lavender","side":"maternal" },
    { "id":"p13","name":"Carl Dixon","glow":"teal","side":"paternal" }
  ],
  "relationships": [
    { "parent_id":"p1","child_id":"p3" },
    { "parent_id":"p2","child_id":"p3" },
    { "parent_id":"p3","child_id":"p5" },
    { "parent_id":"p4","child_id":"p5" },
    { "parent_id":"p5","child_id":"p7" },
    { "parent_id":"p6","child_id":"p7" },
    { "parent_id":"p7","child_id":"p9" },
    { "parent_id":"p8","child_id":"p9" },
    { "parent_id":"p9","child_id":"p11" },
    { "parent_id":"p10","child_id":"p11" },
    { "parent_id":"p11","child_id":"p13" },
    { "parent_id":"p12","child_id":"p13" }
  ],
  "timeline": [
    { "t":0.0,"action":"focus_node","id":"p1","zoom":1.4 },
    { "t":0.4,"action":"reveal_node","id":"p1" },
    { "t":0.9,"action":"reveal_node","id":"p2" },
    { "t":1.6,"action":"draw_edge","from":"p1","to":"p3" },
    { "t":1.6,"action":"draw_edge","from":"p2","to":"p3" },
    { "t":2.0,"action":"focus_node","id":"p3","zoom":1.5 },
    { "t":2.4,"action":"reveal_node","id":"p3" },
    { "t":3.2,"action":"draw_edge","from":"p3","to":"p5" },
    { "t":3.2,"action":"draw_edge","from":"p4","to":"p5" },
    { "t":3.3,"action":"reveal_node","id":"p4" },
    { "t":3.8,"action":"focus_node","id":"p5" },
    { "t":4.1,"action":"reveal_node","id":"p5" },
    { "t":5.0,"action":"draw_edge","from":"p5","to":"p7" },
    { "t":5.0,"action":"draw_edge","from":"p6","to":"p7" },
    { "t":5.1,"action":"reveal_node","id":"p6" },
    { "t":5.7,"action":"focus_node","id":"p7" },
    { "t":6.0,"action":"reveal_node","id":"p7" },
    { "t":6.9,"action":"draw_edge","from":"p7","to":"p9" },
    { "t":6.9,"action":"draw_edge","from":"p8","to":"p9" },
    { "t":7.0,"action":"reveal_node","id":"p8" },
    { "t":7.6,"action":"focus_node","id":"p9" },
    { "t":7.9,"action":"reveal_node","id":"p9" },
    { "t":8.8,"action":"draw_edge","from":"p9","to":"p11" },
    { "t":8.8,"action":"draw_edge","from":"p10","to":"p11" },
    { "t":8.9,"action":"reveal_node","id":"p10" },
    { "t":9.5,"action":"focus_node","id":"p11" },
    { "t":9.8,"action":"reveal_node","id":"p11" },
    { "t":10.7,"action":"draw_edge","from":"p11","to":"p13" },
    { "t":10.7,"action":"draw_edge","from":"p12","to":"p13" },
    { "t":10.8,"action":"reveal_node","id":"p12" },
    { "t":11.4,"action":"focus_node","id":"p13","zoom":1.6 },
    { "t":11.7,"action":"reveal_node","id":"p13" },
    { "t":12.5,"action":"zoom_out","to":"constellation_view","zoom":0.85 }
  ]
}
"""

# ========= HELPERS =========
def sec_to_frame(t): 
    return int(round(t * FPS))

# ---- Engine setup (Eevee Next vs Classic) + background ----
def setup_eevee_any(fps=30, star_strength_next=50.0, star_strength_classic=6.0, edge_strength=3.0):
    """
    - Prefer Eevee Next (BLENDER_EEVEE_NEXT) if available; else Eevee Classic.
    - In Classic: enable Bloom. In Next: no Bloom; we rely on higher Emission.
    - Also sets a dark space background.
    """
    scene = bpy.context.scene
    scene.render.fps = fps

    # Select engine
    engines = tuple(bpy.types.RenderSettings.bl_rna.properties['engine'].enum_items.keys())
    if 'BLENDER_EEVEE_NEXT' in engines:
        scene.render.engine = 'BLENDER_EEVEE_NEXT'
    elif 'BLENDER_EEVEE' in engines:
        scene.render.engine = 'BLENDER_EEVEE'
    else:
        scene.render.engine = 'CYCLES'  # last resort

    is_classic = (scene.render.engine == 'BLENDER_EEVEE')

    # Bloom only exists in Eevee Classic
    if is_classic:
        try:
            ee = scene.eevee
            ee.use_bloom = True
            ee.bloom_intensity = 0.45
            ee.bloom_threshold = 1.0
            ee.use_soft_shadows = True
        except Exception:
            pass

    # Background (deep navy)
    world = scene.world or bpy.data.worlds.new("World")
    scene.world = world
    world.use_nodes = True
    bg = world.node_tree.nodes.get('Background')
    if bg:
        bg.inputs[0].default_value = (0.03, 0.05, 0.12, 1.0)

    # Return recommended emission strengths for later
    return (star_strength_classic if is_classic else star_strength_next), edge_strength

def boost_emission(star_strength=50.0, edge_strength=3.0):
    for mat in bpy.data.materials:
        if not mat.use_nodes:
            continue
        for n in mat.node_tree.nodes:
            if n.type == "EMISSION":
                n.inputs["Strength"].default_value = (
                    edge_strength if "EDGE" in mat.name else star_strength
                )
                
def new_collection(name):
    c = bpy.data.collections.new(name)
    bpy.context.scene.collection.children.link(c)
    return c

def get_or_create_emission_material(name, color):
    mat = bpy.data.materials.get(name)
    if mat: return mat
    mat = bpy.data.materials.new(name)
    mat.use_nodes = True
    nt = mat.node_tree
    for n in list(nt.nodes): nt.nodes.remove(n)
    out = nt.nodes.new("ShaderNodeOutputMaterial")
    emit = nt.nodes.new("ShaderNodeEmission")
    emit.inputs["Color"].default_value = (color[0], color[1], color[2], 1)
    emit.inputs["Strength"].default_value = GLOW_STRENGTH
    nt.links.new(emit.outputs["Emission"], out.inputs["Surface"])
    mat.blend_method = 'BLEND'
    return mat

def color_from_glow(glow):
    table = {
        "blue-green": (0.42, 0.82, 1.00),
        "white-gold": (1.00, 0.91, 0.70),
        "emerald":    (0.40, 0.90, 0.66),
        "gold":       (1.00, 0.83, 0.42),
        "bronze":     (0.85, 0.63, 0.36),
        "bronze-gold":(0.90, 0.73, 0.43),
        "crimson":    (1.00, 0.42, 0.42),
        "green":      (0.48, 0.83, 0.48),
        "lavender":   (0.79, 0.65, 1.00),
        "teal":       (0.45, 0.88, 0.82),
        "earth":      (0.79, 0.69, 0.53),
        # ➕ Add this:
        "pale_blue":  (0.72, 0.83, 1.00)
    }
    return table.get(glow, (0.81, 0.88, 1.00))


def shape_mesh(side):
    if side == "paternal":
        bpy.ops.mesh.primitive_plane_add(size=STAR_SIZE)
        obj = bpy.context.active_object
        obj.rotation_euler.z = math.radians(45)
        return obj
    else:
        bpy.ops.mesh.primitive_circle_add(vertices=24, radius=STAR_SIZE*0.8, fill_type='NGON')
        return bpy.context.active_object

def place_star(person, angle_idx, total):
    angle = 2*math.pi * (angle_idx / max(total, 1))
    x = math.cos(angle) * LAYOUT_RADIUS
    y = math.sin(angle) * LAYOUT_RADIUS
    obj = shape_mesh(person.get("side","maternal"))
    obj.name = f"STAR_{person['id']}"
    obj.location = (x, y, 0.0)
    col = color_from_glow(person.get("glow",""))
    mat = get_or_create_emission_material(f"EMIT_{person['glow']}", col)
    if obj.data.materials: obj.data.materials[0] = mat
    else: obj.data.materials.append(mat)
    obj.hide_render = True
    return obj

def bezier_curve_between(a_loc, b_loc):
    p0 = mathutils.Vector(a_loc)
    p1 = mathutils.Vector(b_loc)
    mid = (p0 + p1) / 2
    ctrl = mathutils.Vector((mid.x, mid.y, 1.2))
    curve_data = bpy.data.curves.new('edgeCurve', type='CURVE')
    curve_data.dimensions = '3D'
    spline = curve_data.splines.new('BEZIER')
    spline.bezier_points.add(2)
    pts = spline.bezier_points
    pts[0].co = p0; pts[1].co = ctrl; pts[2].co = p1
    curve_obj = bpy.data.objects.new('EDGE', curve_data)
    bpy.context.scene.collection.objects.link(curve_obj)
    curve_data.bevel_depth = EDGE_WIDTH
    return curve_obj

def set_visibility_keyframes(obj, frame_on):
    obj.hide_render = True
    obj.keyframe_insert(data_path="hide_render", frame=frame_on-1)
    obj.hide_render = False
    obj.keyframe_insert(data_path="hide_render", frame=frame_on)

def animate_camera_focus(cam_obj, target_loc, frame, zoom=1.4):
    tgt_name = "CamTarget"
    tgt = bpy.data.objects.get(tgt_name)
    if not tgt:
        tgt = bpy.data.objects.new(tgt_name, None)
        bpy.context.scene.collection.objects.link(tgt)
    tgt.location = target_loc
    tgt.keyframe_insert(data_path="location", frame=frame)

    if not any(c.type == 'TRACK_TO' for c in cam_obj.constraints):
        con = cam_obj.constraints.new(type='TRACK_TO')
        con.target = tgt
        con.track_axis = 'TRACK_NEGATIVE_Z'
        con.up_axis = 'UP_Y'

    cam_obj.location = (target_loc[0], target_loc[1]-3.0/zoom, 2.5/zoom)
    cam_obj.keyframe_insert(data_path="location", frame=frame)
    cam = cam_obj.data
    cam.lens = 50/zoom
    cam.keyframe_insert(data_path="lens", frame=frame)

# ========= SCENE SETUP =========
bpy.ops.object.select_all(action='SELECT')
bpy.ops.object.delete(use_global=False)

# Engine setup (Eevee Next/Classic) and background
STAR_EMIT_STRENGTH, EDGE_EMIT_STRENGTH = setup_eevee_any(FPS)

# Camera & light
bpy.ops.object.camera_add(location=(0, -7, 3), rotation=(math.radians(75), 0, 0))
cam = bpy.context.active_object
bpy.context.scene.camera = cam

bpy.ops.object.light_add(type='AREA', location=(0, 0, 5))
bpy.context.active_object.data.energy = 200

# Collections
col_stars = new_collection("Stars")
col_edges = new_collection("Edges")

# ---- Load JSON BEFORE using 'rels' or 'timeline'
data = json.loads(json_text)
people = data["people"]
rels = data.get("relationships", [])
timeline = data.get("timeline", [])

# ---- Create stars
stars = {}
for idx, p in enumerate(people):
    star = place_star(p, idx, len(people))
    # move to Stars collection
    for coll in star.users_collection:
        coll.objects.unlink(star)
    col_stars.objects.link(star)
    stars[p["id"]] = star

# ---- Create edges
for r in rels:
    a = stars.get(r["parent_id"])
    b = stars.get(r["child_id"])
    if not (a and b):
        continue
    curve = bezier_curve_between(a.location, b.location)
    # edge material (soft blue emission)
    mat = get_or_create_emission_material("EMIT_EDGE", (0.64, 0.71, 1.00))
    if len(curve.data.materials):
        curve.data.materials[0] = mat
    else:
        curve.data.materials.append(mat)
    curve.hide_render = True
    # move to Edges collection
    for coll in curve.users_collection:
        coll.objects.unlink(curve)
    col_edges.objects.link(curve)
    curve.name = f"EDGE_{r['parent_id']}_{r['child_id']}"

# ---- Boost emission AFTER materials exist (Eevee Next will glow)
boost_emission(STAR_EMIT_STRENGTH, EDGE_EMIT_STRENGTH)

# ---- Animate per timeline
for evt in timeline:
    t = float(evt.get("t", 0.0))
    frame = sec_to_frame(t)
    action = evt.get("action")

    if action == "reveal_node":
        pid = evt["id"]
        obj = stars.get(pid)
        if obj:
            set_visibility_keyframes(obj, frame)

    elif action == "draw_edge":
        frm, to = evt["from"], evt["to"]
        obj = bpy.data.objects.get(f"EDGE_{frm}_{to}")
        if obj:
            set_visibility_keyframes(obj, frame)

    elif action == "focus_node":
        pid = evt["id"]
        obj = stars.get(pid)
        if obj:
            animate_camera_focus(cam, obj.location, frame, evt.get("zoom", 1.4))

    elif action == "zoom_out":
        animate_camera_focus(cam, mathutils.Vector((0, 0, 0)), frame, evt.get("zoom", 0.9))

# ---- Render range & output
scene = bpy.context.scene
scene.frame_start = 0
scene.frame_end = sec_to_frame(SCENE_DURATION_SECONDS)
scene.render.resolution_x = 1920
scene.render.resolution_y = 1080
scene.render.film_transparent = False

# Output path
out_dir = bpy.path.abspath("//renders")
os.makedirs(out_dir, exist_ok=True)
scene.render.filepath = os.path.join(out_dir, "constellation_")
scene.render.image_settings.file_format = 'FFMPEG'
scene.render.ffmpeg.format = 'MPEG4'
scene.render.ffmpeg.codec = 'H264'
scene.render.ffmpeg.constant_rate_factor = 'MEDIUM'
scene.render.ffmpeg.gopsize = 12
scene.render.ffmpeg.max_b_frames = 2

print("✅ Setup complete. Render → Render Animation to export video.")
